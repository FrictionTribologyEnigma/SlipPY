
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Surface generation and manipulation (slippy.surface) &#8212; slippy 1.1.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Installation" href="installation.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">slippy 1.1.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-slippy.surface"></span><div class="section" id="surface-generation-and-manipulation-slippy-surface">
<h1>Surface generation and manipulation (slippy.surface)<a class="headerlink" href="#surface-generation-and-manipulation-slippy-surface" title="Permalink to this headline">¶</a></h1>
<p>This module contains functions and classes for reading surfaces from file, 
manipulating, generating and analysing surfaces.</p>
<div class="section" id="the-surface-class">
<h2>The Surface class<a class="headerlink" href="#the-surface-class" title="Permalink to this headline">¶</a></h2>
<p>Each of the generation classes are subclasses of the main surface class this
class contains all the functionallity for analysing and displaying surfaces.</p>
<p>This class can be used with experimentally measured surfaces and contains 
functionallity for reading common file types including .csv, .txt and .al3d</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#slippy.surface.Surface" title="slippy.surface.Surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Surface</span></code></a>(**kwargs)</td>
<td>Object for reading, manipulating and plotting surfaces</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="generation-classes">
<h2>Generation classes<a class="headerlink" href="#generation-classes" title="Permalink to this headline">¶</a></h2>
<p>Several generation calsses exist to help generate a wide variety of analytical 
or random surfaces.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#slippy.surface.FlatSurface" title="slippy.surface.FlatSurface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FlatSurface</span></code></a>([slope])</td>
<td>”</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#slippy.surface.RoundSurface" title="slippy.surface.RoundSurface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RoundSurface</span></code></a>(radius[,&nbsp;dimentions])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#slippy.surface.PyramidSurface" title="slippy.surface.PyramidSurface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PyramidSurface</span></code></a>(lengths[,&nbsp;dimentions])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#slippy.surface.RandomSurface" title="slippy.surface.RandomSurface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RandomSurface</span></code></a>([dimentions])</td>
<td>Surfaces based on transformations of random sequences #TODO</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#slippy.surface.DiscFreqSurface" title="slippy.surface.DiscFreqSurface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiscFreqSurface</span></code></a>(frequencies[,&nbsp;amptitudes,&nbsp;…])</td>
<td>Generates a surface containg discrete frequncy components</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#slippy.surface.ProbFreqSurface" title="slippy.surface.ProbFreqSurface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ProbFreqSurface</span></code></a>(H,&nbsp;qr,&nbsp;qs)</td>
<td>Generates a surface with all possible frequencies in the fft represented  with amptitudes described by the probability distrribution given as input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#slippy.surface.HurstFractalSurface" title="slippy.surface.HurstFractalSurface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HurstFractalSurface</span></code></a>(…)</td>
<td>generates a hurst fratal surface with frequency components from q0 to  cut off frequency in even steps of q0.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#slippy.surface.surface_like" title="slippy.surface.surface_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">surface_like</span></code></a>(target_surface[,&nbsp;global_size,&nbsp;…])</td>
<td>Generates a surface similar to the input surface</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#slippy.surface.alicona_read" title="slippy.surface.alicona_read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">alicona_read</span></code></a>(full_path)</td>
<td>Reads .al3d and associated files made by alicona measurment machines</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="slippy.surface.ACF">
<em class="property">class </em><code class="descclassname">slippy.surface.</code><code class="descname">ACF</code><span class="sig-paren">(</span><em>source</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/ACF.html#ACF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.ACF" title="Permalink to this definition">¶</a></dt>
<dd><p>TODO make pretty and test
A class to specify auto corelation functions
used with all surfaces
functions should be usable independent of length
can be directly specified or made from a function (again independent of base grid size)
must ulitimately be expressed on a base grid</p>
<p>should be able to supply:
a surface, a name and params, a function handle(?)
or a grid of values (to interpolate between)
leave a funcion in self.methos that takes x,y points and the grid_spacing then returnds the height of the ACF at those points</p>
<p>__Call__(X,Y) returns the height of the acf at each of the x,y points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>interpolator</strong></dt>
<dd></dd>
<dt><strong>method</strong></dt>
<dd></dd>
<dt><strong>original</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code></td>
<td></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="31%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>input_check_array</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>input_check_method</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>input_check_string</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="slippy.surface.DiscFreqSurface">
<em class="property">class </em><code class="descclassname">slippy.surface.</code><code class="descname">DiscFreqSurface</code><span class="sig-paren">(</span><em>frequencies, amptitudes=[1], phases_rads=[0], dimentions=2, **kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/FFTBased.html#DiscFreqSurface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.DiscFreqSurface" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a surface containg discrete frequncy components</p>
<p>Usage:</p>
<p>DiscFreqSurface(frequencies, amptitudes=[1], phases_rads=[0], dimentions=2)</p>
<p>Generates a surface with the specified frequencies, amptitudes and phases 
any kwargs that can be passed to surface can also be passed to this</p>
<p>mySurf=DiscFreqSurface(10, 0.1) 
mySurf.global_size=[0.5,0.5]
mySurf.descretise(0.001)</p>
<p>Generates and descretises a 2D surface with a frequency of 10 rads/unit
of global size, descretised on a grid with a grid_spacing of 0.001</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>aacf</strong></dt>
<dd></dd>
<dt><strong>acf</strong></dt>
<dd></dd>
<dt><strong>fft</strong></dt>
<dd></dd>
<dt><strong>hist</strong></dt>
<dd></dd>
<dt><strong>psd</strong></dt>
<dd></dd>
<dt><strong>sa</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">birmingham</span></code>(parameter_name[,&nbsp;curved_surface,&nbsp;…])</td>
<td>Find 3d surface roughness parameters</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>([hole_value,&nbsp;mk_copy,&nbsp;…])</td>
<td>Replaces specificed values with filler</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_acf</span></code>([profile_in])</td>
<td>Find the auto corelation function of the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fft</span></code>([profile_in])</td>
<td>Find the fourier transform of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_mat_or_void_volume_ratio</span></code>(height[,&nbsp;void,&nbsp;…])</td>
<td>Finds the material or void volume for a given plane height, uses an  approximation (that each point is a coloumn of material) original  formular didn’t work.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_psd</span></code>()</td>
<td>Find the power spectral density of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_from_file</span></code>(path,&nbsp;**kwargs)</td>
<td>#TODO add documentation to this kwargs can be header lines etc, args is kwargs from init</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate</span></code>()</td>
<td>rotate the surface relative to the grid and reinterpolate</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_global_size</span></code>(global_size)</td>
<td>Changes the global size of the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_grid_spacing</span></code>(grid_spacing)</td>
<td>Change the grid spacing of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>([property_to_plot,&nbsp;plot_type,&nbsp;ax])</td>
<td>Method for plotting anything of interest for the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">subtract_polynomial</span></code>(order[,&nbsp;profile_in])</td>
<td>Flattens the surface by fitting and subtracting a polynomial</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>descretise</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>find_summits</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>get_summit_curvatures</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>low_pass_filter</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>resample</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="slippy.surface.FlatSurface">
<em class="property">class </em><code class="descclassname">slippy.surface.</code><code class="descname">FlatSurface</code><span class="sig-paren">(</span><em>slope=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Geometric.html#FlatSurface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.FlatSurface" title="Permalink to this definition">¶</a></dt>
<dd><p>”
simple flat surface can be angled in any direction by changing slope</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>aacf</strong></dt>
<dd></dd>
<dt><strong>acf</strong></dt>
<dd></dd>
<dt><strong>fft</strong></dt>
<dd></dd>
<dt><strong>hist</strong></dt>
<dd></dd>
<dt><strong>psd</strong></dt>
<dd></dd>
<dt><strong>sa</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">birmingham</span></code>(parameter_name[,&nbsp;curved_surface,&nbsp;…])</td>
<td>Find 3d surface roughness parameters</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>([hole_value,&nbsp;mk_copy,&nbsp;…])</td>
<td>Replaces specificed values with filler</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_acf</span></code>([profile_in])</td>
<td>Find the auto corelation function of the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fft</span></code>([profile_in])</td>
<td>Find the fourier transform of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_mat_or_void_volume_ratio</span></code>(height[,&nbsp;void,&nbsp;…])</td>
<td>Finds the material or void volume for a given plane height, uses an  approximation (that each point is a coloumn of material) original  formular didn’t work.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_psd</span></code>()</td>
<td>Find the power spectral density of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_from_file</span></code>(path,&nbsp;**kwargs)</td>
<td>#TODO add documentation to this kwargs can be header lines etc, args is kwargs from init</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate</span></code>()</td>
<td>rotate the surface relative to the grid and reinterpolate</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_global_size</span></code>(global_size)</td>
<td>Changes the global size of the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_grid_spacing</span></code>(grid_spacing)</td>
<td>Change the grid spacing of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>([property_to_plot,&nbsp;plot_type,&nbsp;ax])</td>
<td>Method for plotting anything of interest for the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">subtract_polynomial</span></code>(order[,&nbsp;profile_in])</td>
<td>Flattens the surface by fitting and subtracting a polynomial</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>descretise</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>find_summits</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>get_summit_curvatures</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>low_pass_filter</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>resample</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="slippy.surface.HurstFractalSurface">
<em class="property">class </em><code class="descclassname">slippy.surface.</code><code class="descname">HurstFractalSurface</code><span class="sig-paren">(</span><em>q0</em>, <em>q0 amptitude</em>, <em>cut off frequency</em>, <em>Hurst parameter</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/FFTBased.html#HurstFractalSurface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.HurstFractalSurface" title="Permalink to this definition">¶</a></dt>
<dd><p>generates a hurst fratal surface with frequency components from q0 to 
cut off frequency in even steps of q0.</p>
<dl class="docutils">
<dt>amptitudes are given by:</dt>
<dd>q0 amptitude**2 <a href="#id1"><span class="problematic" id="id2">*</span></a>((h**2+k**2)/2)^(1-Hurst parameter)</dd>
</dl>
<p>where h,k = -N…N 
where N=cut off frequency/ q0
phases are randomly generated on construction of the surface object,
repeted calls to the descretise function will descretise on the same surface
but repeted calls to this class will generate diferent realisations</p>
<dl class="docutils">
<dt>Example:</dt>
<dd><p class="first">#create the surface object with the specified fractal prameters
my_surface=HurstFractalSurface(1,0.1,1000,2)
#descrtise the surface over a grid 1 unit by 1 unit with a grid_spacing of 0.01
heights=my_surface.descretise(‘grid’, [[0,1],[0,1]], [0.01,0.01])
#interpolate over a previously made grid
heights=my_surface.descretise(‘interp’, X, Y, <a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs) ** kwargs for remaking interpolator and interpolator options
#generate new points (e.g. for a custom grid)
my_surface.descretise(‘points’, X, Y)</p>
<p class="last">A new efficient numerical method for contact mechanics of rough surfaces
C.Putignano L.Afferrante G.Carbone G.Demelio</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>aacf</strong></dt>
<dd></dd>
<dt><strong>acf</strong></dt>
<dd></dd>
<dt><strong>fft</strong></dt>
<dd></dd>
<dt><strong>hist</strong></dt>
<dd></dd>
<dt><strong>psd</strong></dt>
<dd></dd>
<dt><strong>sa</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">birmingham</span></code>(parameter_name[,&nbsp;curved_surface,&nbsp;…])</td>
<td>Find 3d surface roughness parameters</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>([hole_value,&nbsp;mk_copy,&nbsp;…])</td>
<td>Replaces specificed values with filler</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_acf</span></code>([profile_in])</td>
<td>Find the auto corelation function of the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fft</span></code>([profile_in])</td>
<td>Find the fourier transform of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_mat_or_void_volume_ratio</span></code>(height[,&nbsp;void,&nbsp;…])</td>
<td>Finds the material or void volume for a given plane height, uses an  approximation (that each point is a coloumn of material) original  formular didn’t work.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_psd</span></code>()</td>
<td>Find the power spectral density of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_from_file</span></code>(path,&nbsp;**kwargs)</td>
<td>#TODO add documentation to this kwargs can be header lines etc, args is kwargs from init</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate</span></code>()</td>
<td>rotate the surface relative to the grid and reinterpolate</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_global_size</span></code>(global_size)</td>
<td>Changes the global size of the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_grid_spacing</span></code>(grid_spacing)</td>
<td>Change the grid spacing of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>([property_to_plot,&nbsp;plot_type,&nbsp;ax])</td>
<td>Method for plotting anything of interest for the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">subtract_polynomial</span></code>(order[,&nbsp;profile_in])</td>
<td>Flattens the surface by fitting and subtracting a polynomial</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>descretise</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>find_summits</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>get_summit_curvatures</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>low_pass_filter</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>resample</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="slippy.surface.ProbFreqSurface">
<em class="property">class </em><code class="descclassname">slippy.surface.</code><code class="descname">ProbFreqSurface</code><span class="sig-paren">(</span><em>H</em>, <em>qr</em>, <em>qs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/FFTBased.html#ProbFreqSurface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.ProbFreqSurface" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a surface with all possible frequencies in the fft represented 
with amptitudes described by the probability distrribution given as input.
Defaults to the parameters used in the contact mechanics challenge</p>
<p>This class only works for square 2D domains</p>
<p>For more infromation on the definations of the input parameters refer to 
XXXXXX contact mechanics challenge paper</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>aacf</strong></dt>
<dd></dd>
<dt><strong>acf</strong></dt>
<dd></dd>
<dt><strong>fft</strong></dt>
<dd></dd>
<dt><strong>hist</strong></dt>
<dd></dd>
<dt><strong>psd</strong></dt>
<dd></dd>
<dt><strong>sa</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">birmingham</span></code>(parameter_name[,&nbsp;curved_surface,&nbsp;…])</td>
<td>Find 3d surface roughness parameters</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>([hole_value,&nbsp;mk_copy,&nbsp;…])</td>
<td>Replaces specificed values with filler</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_acf</span></code>([profile_in])</td>
<td>Find the auto corelation function of the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fft</span></code>([profile_in])</td>
<td>Find the fourier transform of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_mat_or_void_volume_ratio</span></code>(height[,&nbsp;void,&nbsp;…])</td>
<td>Finds the material or void volume for a given plane height, uses an  approximation (that each point is a coloumn of material) original  formular didn’t work.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_psd</span></code>()</td>
<td>Find the power spectral density of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_from_file</span></code>(path,&nbsp;**kwargs)</td>
<td>#TODO add documentation to this kwargs can be header lines etc, args is kwargs from init</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate</span></code>()</td>
<td>rotate the surface relative to the grid and reinterpolate</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_global_size</span></code>(global_size)</td>
<td>Changes the global size of the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_grid_spacing</span></code>(grid_spacing)</td>
<td>Change the grid spacing of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>([property_to_plot,&nbsp;plot_type,&nbsp;ax])</td>
<td>Method for plotting anything of interest for the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">subtract_polynomial</span></code>(order[,&nbsp;profile_in])</td>
<td>Flattens the surface by fitting and subtracting a polynomial</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>descretise</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>find_summits</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>get_summit_curvatures</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>low_pass_filter</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>resample</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="slippy.surface.PyramidSurface">
<em class="property">class </em><code class="descclassname">slippy.surface.</code><code class="descname">PyramidSurface</code><span class="sig-paren">(</span><em>lengths</em>, <em>dimentions=2</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Geometric.html#PyramidSurface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.PyramidSurface" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>aacf</strong></dt>
<dd></dd>
<dt><strong>acf</strong></dt>
<dd></dd>
<dt><strong>fft</strong></dt>
<dd></dd>
<dt><strong>hist</strong></dt>
<dd></dd>
<dt><strong>psd</strong></dt>
<dd></dd>
<dt><strong>sa</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">birmingham</span></code>(parameter_name[,&nbsp;curved_surface,&nbsp;…])</td>
<td>Find 3d surface roughness parameters</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>([hole_value,&nbsp;mk_copy,&nbsp;…])</td>
<td>Replaces specificed values with filler</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_acf</span></code>([profile_in])</td>
<td>Find the auto corelation function of the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fft</span></code>([profile_in])</td>
<td>Find the fourier transform of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_mat_or_void_volume_ratio</span></code>(height[,&nbsp;void,&nbsp;…])</td>
<td>Finds the material or void volume for a given plane height, uses an  approximation (that each point is a coloumn of material) original  formular didn’t work.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_psd</span></code>()</td>
<td>Find the power spectral density of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_from_file</span></code>(path,&nbsp;**kwargs)</td>
<td>#TODO add documentation to this kwargs can be header lines etc, args is kwargs from init</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate</span></code>()</td>
<td>rotate the surface relative to the grid and reinterpolate</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_global_size</span></code>(global_size)</td>
<td>Changes the global size of the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_grid_spacing</span></code>(grid_spacing)</td>
<td>Change the grid spacing of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>([property_to_plot,&nbsp;plot_type,&nbsp;ax])</td>
<td>Method for plotting anything of interest for the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">subtract_polynomial</span></code>(order[,&nbsp;profile_in])</td>
<td>Flattens the surface by fitting and subtracting a polynomial</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>descretise</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>find_summits</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>get_summit_curvatures</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>low_pass_filter</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>resample</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="slippy.surface.RandomSurface">
<em class="property">class </em><code class="descclassname">slippy.surface.</code><code class="descname">RandomSurface</code><span class="sig-paren">(</span><em>dimentions=2</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Random.html#RandomSurface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.RandomSurface" title="Permalink to this definition">¶</a></dt>
<dd><p>Surfaces based on transformations of random sequences
#TODO</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>aacf</strong></dt>
<dd></dd>
<dt><strong>acf</strong></dt>
<dd></dd>
<dt><strong>fft</strong></dt>
<dd></dd>
<dt><strong>hist</strong></dt>
<dd></dd>
<dt><strong>psd</strong></dt>
<dd></dd>
<dt><strong>sa</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#slippy.surface.RandomSurface.FIR_filter" title="slippy.surface.RandomSurface.FIR_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FIR_filter</span></code></a>(global_size_output,&nbsp;target_acf,&nbsp;…)</td>
<td>Create a 2D FIR filter to produce a surface with the given ACF</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">birmingham</span></code>(parameter_name[,&nbsp;curved_surface,&nbsp;…])</td>
<td>Find 3d surface roughness parameters</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#slippy.surface.RandomSurface.descretise" title="slippy.surface.RandomSurface.descretise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">descretise</span></code></a>([output_size,&nbsp;periodic,&nbsp;create_new])</td>
<td>Create a random surface realisation based on preset paramters</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>([hole_value,&nbsp;mk_copy,&nbsp;…])</td>
<td>Replaces specificed values with filler</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_acf</span></code>([profile_in])</td>
<td>Find the auto corelation function of the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fft</span></code>([profile_in])</td>
<td>Find the fourier transform of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_mat_or_void_volume_ratio</span></code>(height[,&nbsp;void,&nbsp;…])</td>
<td>Finds the material or void volume for a given plane height, uses an  approximation (that each point is a coloumn of material) original  formular didn’t work.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_psd</span></code>()</td>
<td>Find the power spectral density of the surface</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#slippy.surface.RandomSurface.linear_transform" title="slippy.surface.RandomSurface.linear_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linear_transform</span></code></a>(target_ACF,&nbsp;*ACFargs[,&nbsp;…])</td>
<td>Generates a linear transform matrix</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_from_file</span></code>(path,&nbsp;**kwargs)</td>
<td>#TODO add documentation to this kwargs can be header lines etc, args is kwargs from init</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate</span></code>()</td>
<td>rotate the surface relative to the grid and reinterpolate</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_global_size</span></code>(global_size)</td>
<td>Changes the global size of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_grid_spacing</span></code>(grid_spacing)</td>
<td>Change the grid spacing of the surface</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#slippy.surface.RandomSurface.set_moments" title="slippy.surface.RandomSurface.set_moments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_moments</span></code></a>([skew,&nbsp;kurtosis])</td>
<td>Sets the skew and kurtosis of the output surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>([property_to_plot,&nbsp;plot_type,&nbsp;ax])</td>
<td>Method for plotting anything of interest for the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">subtract_polynomial</span></code>(order[,&nbsp;profile_in])</td>
<td>Flattens the surface by fitting and subtracting a polynomial</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>CGD_itt</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>fill</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>find_summits</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>get_summit_curvatures</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>low_pass_filter</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>resample</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>set_quantiles</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="slippy.surface.RandomSurface.FIR_filter">
<code class="descname">FIR_filter</code><span class="sig-paren">(</span><em>global_size_output</em>, <em>target_acf</em>, <em>*ACFargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Random.html#RandomSurface.FIR_filter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.RandomSurface.FIR_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a 2D FIR filter to produce a surface with the given ACF</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>global_size_output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a 2 element list or integer</span></dt>
<dd><p class="first last">The dimentions of the surface to be generated in the same units 
as the grid_spacing property is set in.</p>
</dd>
<dt><strong>target_acf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a SlipPY.ACF object</span></dt>
<dd><p class="first last">The target ACF of the final surface. If the input is not an ACF 
object this method will attempt to make one by passing this and any
other arguments to the ACF constructor</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Nothing, the resulting FIR filter is set as a property in the parent</strong></dt>
<dd></dd>
<dt><strong>object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SlipPY.ACF</span></code>, <a class="reference internal" href="#slippy.surface.RandomSurface.linear_transform" title="slippy.surface.RandomSurface.linear_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RandomSurface.linear_transform</span></code></a>, <a class="reference internal" href="#slippy.surface.RandomSurface.descretise" title="slippy.surface.RandomSurface.descretise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RandomSurface.descretise</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>1 For this function to work the grid_grid_spacing ofthe final surface </dt>
<dd>must be set.</dd>
<dt>2 After runing this method surface realisations can be generated by the </dt>
<dd>descretise method</dd>
<dt>3 Uses the method defined here:</dt>
<dd>Hu, Y. Z., &amp; Tonder, K. (1992). Simulation of 3-D random rough 
surface by 2-D digital filter and Fourier analysis. 
International Journal of Machine Tools and …, 32(1–2), 83–90. 
<a class="reference external" href="https://doi.org/10.1016/0890-6955(92)90064-N">https://doi.org/10.1016/0890-6955(92)90064-N</a></dd>
</dl>
<p class="rubric">Examples</p>
<p>#TODO</p>
</dd></dl>

<dl class="method">
<dt id="slippy.surface.RandomSurface.descretise">
<code class="descname">descretise</code><span class="sig-paren">(</span><em>output_size=[512, 512], periodic=False, create_new=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Random.html#RandomSurface.descretise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.RandomSurface.descretise" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a random surface realisation based on preset paramters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>output_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2 elemeent list of ints, defaults to [512, 512]</span></dt>
<dd><p class="first last">The size of the output in points, the grid_spacing of these points 
is set when the filter coefficents matrix is genreated, see 
linear_transform for more information</p>
</dd>
<dt><strong>periodic</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional defaults to false</span></dt>
<dd><p class="first last">If true the resulting surface will be periodic in geometry, for 
this to work the filter coefficents matrix must have odd order in 
both directions</p>
</dd>
<dt><strong>create_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional defaults to False</span></dt>
<dd><p class="first last">If set to true the method will return a new surface object with the
generated profile and the correct sizes/ grid_spacing otherwise the 
parent surface will given the generated profile</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A new surface object if the create_new parameter is set to true else</strong></dt>
<dd></dd>
<dt><strong>nothing, but sets profile property of surface</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#slippy.surface.RandomSurface.linear_transform" title="slippy.surface.RandomSurface.linear_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RandomSurface.linear_transform</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">RandomSurface.johnson_translator</span></code></p>
</div>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>Uses the method outlined in the below with fft based convoluiton:</dt>
<dd>Liao, D., Shao, W., Tang, J., &amp; Li, J. (2018). An improved rough 
surface modeling method based on linear transformation technique. 
Tribology International, 119(August 2017), 786–794. 
<a class="reference external" href="https://doi.org/10.1016/j.triboint.2017.12.008">https://doi.org/10.1016/j.triboint.2017.12.008</a></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slippy.surface.RandomSurface.linear_transform">
<code class="descname">linear_transform</code><span class="sig-paren">(</span><em>target_ACF, *ACFargs, filter_size_n_m=[35, 35], method='newtonian', **kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Random.html#RandomSurface.linear_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.RandomSurface.linear_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a linear transform matrix</p>
<p>Solves the non linear optimisation problem to generate a 
moving average filter that when convoloved with a set of normally
distributed random numbers will generate a surface profile with the 
sepcified ACF</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>target_ACF</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ACF object or description</span></dt>
<dd><p class="first last">The target ACF, the linear transfrom matrix will produce surfaces
with this ACF.</p>
</dd>
<dt><strong>ACFargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">optional</span></dt>
<dd><p class="first last">If the target_ACF is not an ACF object the target_ACF and the acf
args are passed to the ACF constructor to generate an ACF object</p>
</dd>
<dt><strong>filter_size_n_m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2 element list of int</span></dt>
<dd><p class="first last">The dimentions of the filter coeficent matrix to be genrated 
the defaultis [35, 35]</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘newtonian’, ‘CGD’}</span></dt>
<dd><p class="first last">The method of itteration used to reach the solution, currently only
newtonian iis implemented</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>None</strong></dt>
<dd></dd>
<dt><strong>Sets the filter_coeficents property of the instance</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>max_it</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int default is 100</span></dt>
<dd><p class="first last">The maximum number of iterations used</p>
</dd>
<dt><strong>accuracy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float default is 1e-5</span></dt>
<dd><p class="first last">The accuracy of the itterated solution</p>
</dd>
<dt><strong>min_relax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float default is 1e-6</span></dt>
<dd><p class="first last">The minimum relaxation factor used in the newtonian itterations
see notes</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#slippy.surface.RandomSurface.set_moments" title="slippy.surface.RandomSurface.set_moments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RandomSurface.set_moments</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">RandomSurface.FIRfilter</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This problem has a unique solution for each grid spacing. This should 
be set before running this method, else it is assumed to be 1</p>
<p>The itteration procedure used if newtonian is selected is not strictly 
newtonian. As it is much more time consuming to invert the jacobian 
martix than multiply the result a modified newtonian is used. If the 
next itteration is not an imporovement on the previous itteration the 
‘distance moved’ is halved. This halving is repeted until the 
itteration results in an improvement. The minimum disctance that will 
be tried can be set by setting the min_relax key word. This defaults to 
10e-6. This is a deviation from the method described by <a href="#id45"><span class="problematic" id="id5">[1]_</span></a></p>
<p class="rubric">References</p>
<p>..[1] N. Patir, “A numerical procedure for random generation of 
rough surfaces (1978)”
Wear, 47(2), 263–277. 
‘&lt;<a class="reference external" href="https://doi.org/10.1016/0043-1648(78)90157-6">https://doi.org/10.1016/0043-1648(78)90157-6</a>&gt;’_</p>
</dd></dl>

<dl class="method">
<dt id="slippy.surface.RandomSurface.set_moments">
<code class="descname">set_moments</code><span class="sig-paren">(</span><em>skew=0</em>, <em>kurtosis=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Random.html#RandomSurface.set_moments"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.RandomSurface.set_moments" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Sets the skew and kurtosis of the output surface</p>
<p>If a filter coeficents matrix is present, this method changes the dist
property of this instance to a distribution that produces a series of 
johnson or normally distributed random numbers that will have the 
set skew and kurtosis when convolved with the filter coeficents matrix.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>skew, kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The desired moments of the surface profile</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>None</strong></dt>
<dd><p class="first last">Sets the dist parameter of the instance</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{sum_{i=0}^{q} lpha_{i}^{3}}{(sum_{i=0}^{q}lpha_i^2)^
rac{3}{2}}</p>
<blockquote>
<div><p>The kurtosis of the input sequence can be related to the final surface 
by [Rdb32fdd53436-1]:</p>
<dl class="docutils">
<dt>..math:</dt>
<dd>K_z=</dd>
</dl>
</div></blockquote>
<p>rac{<a href="#id46"><span class="problematic" id="id47">K_</span></a>eta sum_{i=0}^q lpha_i^2 + 6 sum_{i=0}^{q-1}sum_{j=i+1}^q lpha_i^2 lpha_j^2}{(sum_{i=0}^q lpha_i^2)^2}</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="slippy.surface.RoundSurface">
<em class="property">class </em><code class="descclassname">slippy.surface.</code><code class="descname">RoundSurface</code><span class="sig-paren">(</span><em>radius</em>, <em>dimentions=2</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Geometric.html#RoundSurface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.RoundSurface" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>aacf</strong></dt>
<dd></dd>
<dt><strong>acf</strong></dt>
<dd></dd>
<dt><strong>fft</strong></dt>
<dd></dd>
<dt><strong>hist</strong></dt>
<dd></dd>
<dt><strong>psd</strong></dt>
<dd></dd>
<dt><strong>sa</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">birmingham</span></code>(parameter_name[,&nbsp;curved_surface,&nbsp;…])</td>
<td>Find 3d surface roughness parameters</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>([hole_value,&nbsp;mk_copy,&nbsp;…])</td>
<td>Replaces specificed values with filler</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_acf</span></code>([profile_in])</td>
<td>Find the auto corelation function of the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fft</span></code>([profile_in])</td>
<td>Find the fourier transform of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_mat_or_void_volume_ratio</span></code>(height[,&nbsp;void,&nbsp;…])</td>
<td>Finds the material or void volume for a given plane height, uses an  approximation (that each point is a coloumn of material) original  formular didn’t work.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_psd</span></code>()</td>
<td>Find the power spectral density of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_from_file</span></code>(path,&nbsp;**kwargs)</td>
<td>#TODO add documentation to this kwargs can be header lines etc, args is kwargs from init</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate</span></code>()</td>
<td>rotate the surface relative to the grid and reinterpolate</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_global_size</span></code>(global_size)</td>
<td>Changes the global size of the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_grid_spacing</span></code>(grid_spacing)</td>
<td>Change the grid spacing of the surface</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>([property_to_plot,&nbsp;plot_type,&nbsp;ax])</td>
<td>Method for plotting anything of interest for the surface</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">subtract_polynomial</span></code>(order[,&nbsp;profile_in])</td>
<td>Flattens the surface by fitting and subtracting a polynomial</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>descretise</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>find_summits</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>get_summit_curvatures</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>low_pass_filter</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>resample</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="slippy.surface.Surface">
<em class="property">class </em><code class="descclassname">slippy.surface.</code><code class="descname">Surface</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Surface.html#Surface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.Surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Object for reading, manipulating and plotting surfaces</p>
<p>The basic surface class contains methods for setting properties, 
examining measures of roughness and descriptions of surfaces, plotting,
fixing and editing surfaces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>file_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str optional (None)</span></dt>
<dd><p class="first last">The file name including the extention of file, for vaild types see 
notes</p>
</dd>
<dt><strong>delim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str optional (‘,’)</span></dt>
<dd><p class="first last">The delimitor used in the file, only needed for csv or txt files</p>
</dd>
<dt><strong>profile</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like optional (np.array([]))</span></dt>
<dd><p class="first last">A surface profile</p>
</dd>
<dt><strong>global_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2 element list optional (None)</span></dt>
<dd><p class="first last">The size of the surface in each dimention</p>
</dd>
<dt><strong>grid_spacing</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float optional (None)</span></dt>
<dd><p class="first last">The distance between nodes on the grid,</p>
</dd>
<dt><strong>dimentions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int optional (2)</span></dt>
<dd><p class="first last">The number of diimentions of the surface</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<dl class="docutils">
<dt>#TODO:</dt>
<dd><p class="first">priority
get_quantiles(n) # n is the number of quantiles needed… might not be necessary or might want to change how hist (in show) works to work with it
rotate</p>
<p>Then start checking stuff
make init work with these options 
Add desciption and example of each method 
check summit finding</p>
<p>def mesh</p>
<p class="last">Make this pretty ^</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>acf, psd, fft</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array or None</span></dt>
<dd><p class="first last">The acf, psd and fft of the surface set by the get_acf get_psd and
get_fft methods</p>
</dd>
<dt><strong>profile</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The height infromation of the surface</p>
</dd>
<dt><strong>surface_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">A description of the surface type</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#slippy.surface.Surface.set_global_size" title="slippy.surface.Surface.set_global_size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_global_size</span></code></a></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#slippy.surface.Surface.set_grid_spacing" title="slippy.surface.Surface.set_grid_spacing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_grid_spacing</span></code></a></td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#slippy.surface.Surface.get_fft" title="slippy.surface.Surface.get_fft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fft</span></code></a></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#slippy.surface.Surface.get_acf" title="slippy.surface.Surface.get_acf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_acf</span></code></a></td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#slippy.surface.Surface.get_psd" title="slippy.surface.Surface.get_psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_psd</span></code></a></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="slippy.surface.Surface.birmingham">
<code class="descname">birmingham</code><span class="sig-paren">(</span><em>parameter_name</em>, <em>curved_surface=False</em>, <em>periodic_surface=False</em>, <em>profile_in=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Surface.html#Surface.birmingham"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.Surface.birmingham" title="Permalink to this definition">¶</a></dt>
<dd><p>Find 3d surface roughness parameters</p>
<p>Calculates and returns common surface roughness parameters also known 
as birmingham parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>parameter_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str</span></dt>
<dd><p class="first last">The name of the surface roughness parameter to be returned see note</p>
</dd>
<dt><strong>curved_surface</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool optional (False)</span></dt>
<dd><p class="first last">True if the measurment surface was curved, see note</p>
</dd>
<dt><strong>periodic_surface</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool optioal (False)</span></dt>
<dd><p class="first last">True if the surface is periodic</p>
</dd>
<dt><strong>profile_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like optional (None)</span></dt>
<dd><p class="first last">If a profile is supplied the parameters will be calculated on that 
profile, limited support</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or list of float</span></dt>
<dd><p class="first last">The requested parameters</p>
</dd>
<dt><strong>from: Stout, K., Sullivan, P., Dong, W., Mainsah, E., Luo, N., Mathia,</strong></dt>
<dd></dd>
<dt><strong>T., &amp; Zahouani, H. (1993).</strong></dt>
<dd></dd>
<dt><strong>The development of methods for the characterisation of roughness in</strong></dt>
<dd></dd>
<dt><strong>three dimensions. EUR(Luxembourg), 358.</strong></dt>
<dd></dd>
<dt><strong>Retrieved from http://cat.inist.fr/?aModele=afficheN&amp;cpsidt=49475</strong></dt>
<dd></dd>
<dt><strong>chapter 12</strong></dt>
<dd></dd>
<dt><strong>Returns the 3D surface parameters as defined in the above text:</strong></dt>
<dd></dd>
<dt><strong>Before calculation the least squares plane is subtracted if a periodic</strong></dt>
<dd></dd>
<dt><strong>surface is used this can be prevented by setting periodic_surface to</strong></dt>
<dd></dd>
<dt><strong>true. If a curved surface is used a bi quadratic polynomial is fitted</strong></dt>
<dd></dd>
<dt><strong>and removed before analysis as descirbed in the above text.</strong></dt>
<dd></dd>
<dt><strong>If a list of valid parameter names is given this method will return a</strong></dt>
<dd></dd>
<dt><strong>list of parameter values.</strong></dt>
<dd></dd>
<dt><strong>If a parameter based on summit descriptions is needed the key words:</strong></dt>
<dd><p class="first last">filter_cut_off (default False)
and 
four_nearest (default False)</p>
</dd>
<dt><strong>can be set to refine what counts as a summit, see Surface.find_summits</strong></dt>
<dd></dd>
<dt><strong>for more information. This is only used to find summits, calculations</strong></dt>
<dd></dd>
<dt><strong>are run on ‘raw’ surface.</strong></dt>
<dd></dd>
<dt><strong>Descriptions of the parameters are given below.</strong></dt>
<dd></dd>
<dt><a href="#id7"><span class="problematic" id="id8">**</span></a>** Amptitude parameters <a href="#id9"><span class="problematic" id="id10">**</span></a><a href="#id11"><span class="problematic" id="id12">**</span></a></dt>
<dd><p class="first last">Sq   - RMS deviation of surface height
Sz   - Ten point height (based on definition of sumits)
Ssk  - ‘Skewness’ of the surface (3rd moment)
Sku  - ‘Kurtosis’ of the surface (4th moment)</p>
</dd>
<dt><a href="#id13"><span class="problematic" id="id14">**</span></a>** Spartial parameters <a href="#id15"><span class="problematic" id="id16">**</span></a><a href="#id17"><span class="problematic" id="id18">**</span></a></dt>
<dd><p class="first last">Sds  - Summit density, see note above on definition of summit
Str  - Texture aspect ratio defined using the aacf
Std  - Texture direction
Sal  - Fastest decay auto corelation length</p>
</dd>
<dt><a href="#id19"><span class="problematic" id="id20">**</span></a>** hybrid parameters <a href="#id21"><span class="problematic" id="id22">**</span></a><a href="#id23"><span class="problematic" id="id24">**</span></a></dt>
<dd><p class="first last">Sdelq- RMS slope
Ssc  - Mean summit curvature, see note above on definition of summit 
Sdr  - Developed interfacial area ratio</p>
</dd>
<dt><a href="#id25"><span class="problematic" id="id26">**</span></a>** funcional parameters <a href="#id27"><span class="problematic" id="id28">**</span></a><a href="#id29"><span class="problematic" id="id30">**</span></a></dt>
<dd><p class="first">Sbi  - Bearing index
Sci  - Core fluid retention index - not implemented with equation</p>
<blockquote>
<div><p>book, appears to be incorrect, instead simple aproximation 
used, produces warning when used</p>
</div></blockquote>
<dl class="last docutils">
<dt>Svi  - Valley fluid retention index - see note above, produces </dt>
<dd><p class="first last">produces warning when used</p>
</dd>
</dl>
</dd>
<dt><a href="#id31"><span class="problematic" id="id32">**</span></a>** non ‘core’ parameters (implemented) <a href="#id33"><span class="problematic" id="id34">**</span></a><a href="#id35"><span class="problematic" id="id36">**</span></a></dt>
<dd><p class="first">Sa   - Mean amptitude of surface
Stp  - Surface bearing ratio returns a listof curve points</p>
<blockquote>
<div><p>normalised as described in the above text
this is implemented without any interpolation</p>
</div></blockquote>
<dl class="docutils">
<dt>Smr  - Material volume ratio of the surface required for ‘sci’, see</dt>
<dd><p class="first last">note above</p>
</dd>
</dl>
<p class="last">Svr  - Void volume ratio of the surface, as for previous</p>
</dd>
<dt><a href="#id37"><span class="problematic" id="id38">**</span></a>** non ‘core’ parameters (not implemented) <a href="#id39"><span class="problematic" id="id40">**</span></a><a href="#id41"><span class="problematic" id="id42">**</span></a></dt>
<dd><p class="first last">Sk   - Core roughness depth
Spk  - Reduced summit height
Svk  - Reduced valley depth
Sr1  - Upper bearing area
Sr2  - Lower bearing area</p>
</dd>
<dt><strong>examples:</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="slippy.surface.Surface.fill_holes">
<code class="descname">fill_holes</code><span class="sig-paren">(</span><em>hole_value='auto'</em>, <em>mk_copy=False</em>, <em>remove_boarder=True</em>, <em>b_thresh=0.99</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Surface.html#Surface.fill_holes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.Surface.fill_holes" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces specificed values with filler</p>
<p>Uses biharmonic equations algorithm to fill holes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>hole_value: {‘auto’ or float}</strong></dt>
<dd><p class="first last">The value to be replaced, ‘auto’ replaces all -inf, inf and nan 
values</p>
</dd>
<dt><strong>mk_copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">if set to true a new surface object will be returned with the holes 
filled otherwise the profile property of the current surface is 
updated</p>
</dd>
<dt><strong>remove_boarder</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Defaults to true, removes the boarder from the image until the 
first row and column that have</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>If mk_copy is true a new surface object with holes filled else resets</strong></dt>
<dd></dd>
<dt><strong>profile property of the instance and returns nothing</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.restoration.inpaint.inpaint_biharmonic</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>When alicona images are imported the invalid pixel value is 
automatically set to nan so this will work in auto mode</p>
<p>Holes are filled with bi harmonic equations</p>
</dd></dl>

<dl class="method">
<dt id="slippy.surface.Surface.get_acf">
<code class="descname">get_acf</code><span class="sig-paren">(</span><em>profile_in=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Surface.html#Surface.get_acf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.Surface.get_acf" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the auto corelation function of the surface</p>
<p>Findes the ACF of the surface and stores it in your_instance.acf</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>profile_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like optional (None)</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ACF object</span></dt>
<dd><p class="first last">An acf object with the acf data stored, the values can be extracted
by numpy.array(output)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#slippy.surface.Surface.get_psd" title="slippy.surface.Surface.get_psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_psd</span></code></a>, <a class="reference internal" href="#slippy.surface.Surface.get_fft" title="slippy.surface.Surface.get_fft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fft</span></code></a>, <a class="reference internal" href="#slippy.surface.Surface.show" title="slippy.surface.Surface.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code></a>, <a class="reference internal" href="#slippy.surface.ACF" title="slippy.surface.ACF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slippy.surface.ACF</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>ACF data is kept in ACF objects, these can then be interpolated or 
evaluated at specific points with a call:
&gt;&gt;&gt;acf_data_grid=my_acf_object(new_x_pts,new_y_pts)</p>
<p class="rubric">Examples</p>
<p>&gt;&gt;&gt;my_surface.get_acf()
Sets the acf property of the surface with an ACF object</p>
<p>&gt;&gt;&gt;numpy.array(my_surface.acf)
Then gives the acf values</p>
<p>&gt;&gt;&gt;ACF_object_for_profile_2=my_surface.get_acf(profile_2)
Returns the ACF of a provided profile, equvalent to ACF(profile_2)</p>
</dd></dl>

<dl class="method">
<dt id="slippy.surface.Surface.get_fft">
<code class="descname">get_fft</code><span class="sig-paren">(</span><em>profile_in=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Surface.html#Surface.get_fft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.Surface.get_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the fourier transform of the surface</p>
<p>Findes the fft of the surface and stores it in your_instance.fft</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>surf_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like optional (None)</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transform</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The fft of the instance’s profile or the profile_in if one is 
supplied</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#slippy.surface.Surface.get_psd" title="slippy.surface.Surface.get_psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_psd</span></code></a>, <a class="reference internal" href="#slippy.surface.Surface.get_acf" title="slippy.surface.Surface.get_acf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_acf</span></code></a>, <a class="reference internal" href="#slippy.surface.Surface.show" title="slippy.surface.Surface.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Uses numpy fft.fft or fft.fft2 depending on the shape of the profile</p>
<p class="rubric">Examples</p>
<p>&gt;&gt;&gt;# Set the fft property of the surface
&gt;&gt;&gt;my_surface.get_fft()</p>
<p>&gt;&gt;&gt;# Return the fft of a provided profile
&gt;&gt;&gt;fft_of_profile_2=my_surface.get_fft(profile_2)</p>
</dd></dl>

<dl class="method">
<dt id="slippy.surface.Surface.get_mat_or_void_volume_ratio">
<code class="descname">get_mat_or_void_volume_ratio</code><span class="sig-paren">(</span><em>height</em>, <em>void=False</em>, <em>p=None</em>, <em>ratio=True</em>, <em>volume_ratio=None</em>, <em>threshold=0.001</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Surface.html#Surface.get_mat_or_void_volume_ratio"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.Surface.get_mat_or_void_volume_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the material or void volume for a given plane height, uses an 
approximation (that each point is a coloumn of material) original 
formular didn’t work. Produces warning to this effect.</p>
<p>height  - the height of the cut off plane
void    - if set to true the void volume will be calculated
p       - default is self.profile other profiles can be provided if</p>
<blockquote>
<div>needed</div></blockquote>
<dl class="docutils">
<dt>volume  - if provided the function will be ‘reversed’ and the height of</dt>
<dd>cut off plane which produces the desired volume will be 
returned, this is done by recursive calls to this function 
with binary searching. the process stops after the threshold 
has been reached</dd>
<dt>threshold - the threshold used for binary searching of the height,</dt>
<dd>only used if volume is provided threshold is a fraction of 
total surface height range</dd>
</dl>
<p>returns:</p>
<p>the void or material volume ratio, the height.
if ‘max’ or ‘min’ are supled as the height the actual volume will be 
returned</p>
</dd></dl>

<dl class="method">
<dt id="slippy.surface.Surface.get_psd">
<code class="descname">get_psd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Surface.html#Surface.get_psd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.Surface.get_psd" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the power spectral density of the surface</p>
<p>Findes the fft of the surface and stores it in your_instance.fft</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>(None)</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>(None), sets the psd attribute of the instance</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#slippy.surface.Surface.get_fft" title="slippy.surface.Surface.get_fft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fft</span></code></a>, <a class="reference internal" href="#slippy.surface.Surface.get_acf" title="slippy.surface.Surface.get_acf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_acf</span></code></a>, <a class="reference internal" href="#slippy.surface.Surface.show" title="slippy.surface.Surface.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Finds the psd by fouriertransforming the ACF, in doing so looks for the
instance’s acf property. if this is not found the acf is calculated and 
set</p>
<p class="rubric">Examples</p>
<p>&gt;&gt;my_surface.get_psd()
sets the psd attribute of my_surface</p>
</dd></dl>

<dl class="method">
<dt id="slippy.surface.Surface.read_from_file">
<code class="descname">read_from_file</code><span class="sig-paren">(</span><em>path</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Surface.html#Surface.read_from_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.Surface.read_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>#TODO add documentation to this
kwargs can be header lines etc, args is kwargs from init</p>
</dd></dl>

<dl class="method">
<dt id="slippy.surface.Surface.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Surface.html#Surface.rotate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.Surface.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>rotate the surface relative to the grid and reinterpolate</p>
</dd></dl>

<dl class="method">
<dt id="slippy.surface.Surface.set_global_size">
<code class="descname">set_global_size</code><span class="sig-paren">(</span><em>global_size</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Surface.html#Surface.set_global_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.Surface.set_global_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the global size of the surface</p>
<p>Sets the global size of the surface without reinterpolation, keeps all
other dimnetions up to date</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>global_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2 element list</span></dt>
<dd><p class="first last">The global size to be set in length units</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Nothing</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code>, <a class="reference internal" href="#slippy.surface.Surface.set_grid_spacing" title="slippy.surface.Surface.set_grid_spacing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_grid_spacing</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This method should be used over editing the properties directly</p>
</dd></dl>

<dl class="method">
<dt id="slippy.surface.Surface.set_grid_spacing">
<code class="descname">set_grid_spacing</code><span class="sig-paren">(</span><em>grid_spacing</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Surface.html#Surface.set_grid_spacing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.Surface.set_grid_spacing" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the grid spacing of the surface</p>
<p>Changes the grid spacing attribute while keeping all other dimentions 
up to date. Does not re interpolate on a different size grid, 
stretches the surface to the new grid size keeping all points the same.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>grid_spacing</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The grid spacing to be set in length units</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Nothing</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code>, <a class="reference internal" href="#slippy.surface.Surface.set_global_size" title="slippy.surface.Surface.set_global_size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_global_size</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Use this to set dimentions of the surface rather than setting directly 
should keep all the other dimentions up to date.</p>
</dd></dl>

<dl class="method">
<dt id="slippy.surface.Surface.show">
<code class="descname">show</code><span class="sig-paren">(</span><em>property_to_plot='profile'</em>, <em>plot_type='default'</em>, <em>ax=False</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Surface.html#Surface.show"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.Surface.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for plotting anything of interest for the surface</p>
<p>If a list of properties is provided all will be plotted on separate 
sub plots of the same (new) figure, if a list of plot types is also
provided these will be used as the types, if a single type is provided 
this will be used for all applicable plots, if the list is too short it
will be extended to the same length as the list of properties with 
the default options for the polts.</p>
<p>output : a list of axis handles</p>
<dl class="docutils">
<dt>Valid propertie to plot are:</dt>
<dd>** 2D types **
profile
fft2D
psd
acf
** 1D types **
histogram
fft1D
disthist - requires seaborn histogram of data with dist fitted
QQ - name of distribution must also be provided as <em>args 
*</em> other **
other can be given if <a href="#id43"><span class="problematic" id="id44">*</span></a>args contains 2 or 3 lists of items a 1 or 2
dimentional plot of type surface or line will be plotted, this is 
primarily for debugging and options are limited</dd>
<dt>Valid plot types and the default type depend on the property_to_plot:</dt>
<dd>** for 2D types **
surface - default
image
image_wrap - image plot but wraps corners to centre common for fft
mesh
** for 1D types **
bar - default for histogram
line - default for fft1D
scatter
area</dd>
<dt>example:</dt>
<dd>self.show([‘fft2D’,’fft2D’,’fft2D’], [‘mesh’, ‘image’, ‘default’])
shows the 2D fft of the surface profile with a range of plot types</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slippy.surface.Surface.subtract_polynomial">
<code class="descname">subtract_polynomial</code><span class="sig-paren">(</span><em>order</em>, <em>profile_in=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Surface.html#Surface.subtract_polynomial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.Surface.subtract_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Flattens the surface by fitting and subtracting a polynomial</p>
<p>Fits a polynomail to the surface the subtracts it from the surface, to
remove slope or curve from imaging machines</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The order of the polynomial to be fitted</p>
</dd>
<dt><strong>profile_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like optional</span></dt>
<dd><p class="first last">if set the operation is perfomed on this profile rather than the 
profile of the instance, the profile of the instance is not updated</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>adjusted</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The flattened profile</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#slippy.surface.Surface.birmingham" title="slippy.surface.Surface.birmingham"><code class="xref py py-obj docutils literal notranslate"><span class="pre">birmingham</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.linalg.lstsq</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>In principal polynomials of any integer order are supported</p>
<p class="rubric">Examples</p>
<p>&gt;&gt;&gt;my_surface.subtract_polynomail(2)
Subtract a quadratic polynomial from the profile of my_surface
the result is returned and the profile attribute is updated</p>
<p>&gt;&gt;&gt;flat_profile=my_surface.subtract_polynomial(2,my_surface.profile)
Subtract a quadratic polynomial from the profile of my_surface and
returns the result, the profile attribute is not updated</p>
<p>&gt;&gt;&gt;flat_profile_2=my_surface.subtract_polynomail(1, profile_2)
Subtract a plae of best fit from profile_2 are return the result, the
profile property of my_surface is not changed</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="slippy.surface.alicona_read">
<code class="descclassname">slippy.surface.</code><code class="descname">alicona_read</code><span class="sig-paren">(</span><em>full_path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/alicona.html#alicona_read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.alicona_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads .al3d and associated files made by alicona measurment machines</p>
<p>Will look for texture and icon images automatically, reads tags and depth 
data at a minimum from the al3d file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>full_path</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The full path including extention to an al3d file</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Actual keys depend on the data found:
‘DepthData’ : Array of depth data with nan in place of invalid values
‘TextureData’ : Array of texture data or image of the surface
‘Header’ : Dict of tags read from the header
‘Icon’ : Array of icon image data</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This is a port of the matlab function from the Alicona file format reader 
(al3D) tool box</p>
<p>Copyright (c) 2016, Martin
All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<ul class="simple">
<li>Redistributions of source code must retain the above copyright notice,</li>
</ul>
<p>this list of conditions and the following disclaimer.</p>
<ul class="simple">
<li>Redistributions in binary form must reproduce the above copyright notice,</li>
</ul>
<p>this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.</p>
</dd></dl>

<dl class="function">
<dt id="slippy.surface.surface_like">
<code class="descclassname">slippy.surface.</code><code class="descname">surface_like</code><span class="sig-paren">(</span><em>target_surface, global_size='original', grid_spacing='original', filter_size=[35, 35], **kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slippy/surface/Random.html#surface_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slippy.surface.surface_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a surface similar to the input surface</p>
<p>Generates a surface with the same ACF, skew and kurtosis as the input
surface assuming the surface is normally distributed</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>target_surface</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Surface</span></dt>
<dd><p class="first last">A surface object to be ‘copied’</p>
</dd>
<dt><strong>global_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘origninal’ or 2 element list of ints}</span></dt>
<dd><p class="first last">The size in each direction of the output surface, 
if ‘original’ the dimentions of the input surface are used</p>
</dd>
<dt><strong>grid_spacing</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘original’ or float}</span></dt>
<dd><p class="first last">The spacing between grid points, if ‘original’ the grid spacing of the 
input surface is used, if this property is not set for the input
surface it is assumed that both are 1 and warns</p>
</dd>
<dt><strong>filter_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2 element list of ints</span></dt>
<dd><p class="first last">The size of the filter to be used defaults to [35, 35]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>surf_out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Surface</span></dt>
<dd><p class="first last">A surface object with the same properties as the original surface
of the scale and size requested with keyword arguments</p>
</dd>
<dt><strong>Raises</strong></dt>
<dd></dd>
<dt><strong>—–</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first docutils">
<dt><strong>key word arguments</strong></dt>
<dd></dd>
<dt><strong>periodic</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool default False</span></dt>
<dd><p class="first last">If true the returned surface will have a periodic profile</p>
</dd>
<dt><strong>filter_kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Keyword arguments that are passed to RandomSurface.linear_transforms 
see that for more infromation</p>
</dd>
<dt><strong>dist_type: {‘johnson’, ‘kernel’}</strong></dt>
<dd><p class="first last">Defaults to johnson, the distribution that will be used to draw random
samples for the pre-filter sequence, if johnson a johnson distribution
will be fitted to the input surface quartiles, if kernel a kernel 
distribution will be made from the input histogram, this is 
experimental</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Warns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>If the grid spacing property is not set on the input surface and ‘original’</strong></dt>
<dd></dd>
<dt><strong>is given as the grid spacing arg will assume both are 1 and produce a</strong></dt>
<dd></dd>
<dt><strong>warning</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RandomSurface.linear_transforms</span></code>, <a class="reference internal" href="#slippy.surface.RandomSurface" title="slippy.surface.RandomSurface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RandomSurface</span></code></a>, <a class="reference internal" href="#slippy.surface.Surface" title="slippy.surface.Surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Surface</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>If multiple realisations are needed of the same ‘copied’ surface it will
be much faster to call the descretise function of the returned surface. 
multiple surfaces of the same grid spacing but different grid sizes can be 
generated this way.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Surface generation and manipulation (slippy.surface)</a><ul>
<li><a class="reference internal" href="#the-surface-class">The Surface class</a></li>
<li><a class="reference internal" href="#generation-classes">Generation classes</a></li>
<li><a class="reference internal" href="#functions">Functions</a><ul>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="installation.html"
                        title="previous chapter">Installation</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/surface.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">slippy 1.1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Mike Watson.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>
  </body>
</html>